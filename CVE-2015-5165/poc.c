#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <sys/io.h>
#include <sys/types.h>
#include <unistd.h>
#include <string.h>

// 页面相关
#define PAGE_SHIFT 12
#define PAGE_SIZE (1 << PAGE_SHIFT)
#define PAGE_PRESENT (1ULL << 63)
#define PAGE_PFN ((1ULL << 55) - 1)

// RTL8139 PMIO base address
#define PMIO_BASE 0xC000

// Ethernet Frame
// DST(6) + SRC(6) + Length/Type(2) + MTU(1500)
#define RTL8139_BUFFER_SIZE 1514

/* w0 ownership flag */
#define CP_RX_OWN (1<<31)

/* w0 ownership flag */
#define CP_TX_OWN (1<<31)
/* w0 end of ring flag */
#define CP_TX_EOR (1<<30)
/* first segment of received packet flag */
#define CP_TX_FS (1<<29)
/* last segment of received packet flag */
#define CP_TX_LS (1<<28)
/* large send packet flag */
#define CP_TX_LGSEN (1<<27)
/* large send MSS mask, bits 16...25 */
#define CP_TC_LGSEN_MSS_MASK ((1 << 12) - 1)

/* IP checksum offload flag */
#define CP_TX_IPCS (1<<18)
/* UDP checksum offload flag */
#define CP_TX_UDPCS (1<<17)
/* TCP checksum offload flag */
#define CP_TX_TCPCS (1<<16)

/* w0 bits 0...15 : buffer size */
#define CP_TX_BUFFER_SIZE (1<<16)
#define CP_TX_BUFFER_SIZE_MASK (CP_TX_BUFFER_SIZE - 1)
/* w1 add tag flag */
#define CP_TX_TAGC (1<<17)
/* w1 bits 0...15 : VLAN tag (big endian) */
#define CP_TX_VLAN_TAG_MASK ((1<<16) - 1)
/* w2 low  32bit of Rx buffer ptr */
/* w3 high 32bit of Rx buffer ptr */

/* set after transmission */
/* FIFO underrun flag */
#define CP_TX_STATUS_UNF (1<<25)
/* transmit error summary flag, valid if set any of three below */
#define CP_TX_STATUS_TES (1<<23)
/* out-of-window collision flag */
#define CP_TX_STATUS_OWC (1<<22)
/* link failure flag */
#define CP_TX_STATUS_LNKF (1<<21)
/* excessive collisions flag */
#define CP_TX_STATUS_EXC (1<<20)

/* Symbolic offsets to registers. */
enum RTL8139_registers {
    MAC0 = 0,        /* Ethernet hardware address. */
    MAR0 = 8,        /* Multicast filter. */
    TxStatus0 = 0x10,/* Transmit status (Four 32bit registers). C mode only */
                     /* Dump Tally Conter control register(64bit). C+ mode only */
    TxAddr0 = 0x20,  /* Tx descriptors (also four 32bit). */
    RxBuf = 0x30,
    ChipCmd = 0x37,
    RxBufPtr = 0x38,
    RxBufAddr = 0x3A,
    IntrMask = 0x3C,
    IntrStatus = 0x3E,
    TxConfig = 0x40,
    RxConfig = 0x44,
    Timer = 0x48,        /* A general-purpose counter. */
    RxMissed = 0x4C,    /* 24 bits valid, write clears. */
    Cfg9346 = 0x50,
    Config0 = 0x51,
    Config1 = 0x52,
    FlashReg = 0x54,
    MediaStatus = 0x58,
    Config3 = 0x59,
    Config4 = 0x5A,        /* absent on RTL-8139A */
    HltClk = 0x5B,
    MultiIntr = 0x5C,
    PCIRevisionID = 0x5E,
    TxSummary = 0x60, /* TSAD register. Transmit Status of All Descriptors*/
    BasicModeCtrl = 0x62,
    BasicModeStatus = 0x64,
    NWayAdvert = 0x66,
    NWayLPAR = 0x68,
    NWayExpansion = 0x6A,
    /* Undocumented registers, but required for proper operation. */
    FIFOTMS = 0x70,        /* FIFO Control and test. */
    CSCR = 0x74,        /* Chip Status and Configuration Register. */
    PARA78 = 0x78,
    PARA7c = 0x7c,        /* Magic transceiver parameter register. */
    Config5 = 0xD8,        /* absent on RTL-8139A */
    /* C+ mode */
    TxPoll        = 0xD9,    /* Tell chip to check Tx descriptors for work */
    RxMaxSize    = 0xDA, /* Max size of an Rx packet (8169 only) */
    CpCmd        = 0xE0, /* C+ Command register (C+ mode only) */
    IntrMitigate    = 0xE2,    /* rx/tx interrupt mitigation control */
    RxRingAddrLO    = 0xE4, /* 64-bit start addr of Rx ring */
    RxRingAddrHI    = 0xE8, /* 64-bit start addr of Rx ring */
    TxThresh    = 0xEC, /* Early Tx threshold */
};

/* Bits in TxConfig. */
enum tx_config_bits {

        /* Interframe Gap Time. Only TxIFG96 doesn't violate IEEE 802.3 */
        TxIFGShift = 24,
        TxIFG84 = (0 << TxIFGShift),    /* 8.4us / 840ns (10 / 100Mbps) */
        TxIFG88 = (1 << TxIFGShift),    /* 8.8us / 880ns (10 / 100Mbps) */
        TxIFG92 = (2 << TxIFGShift),    /* 9.2us / 920ns (10 / 100Mbps) */
        TxIFG96 = (3 << TxIFGShift),    /* 9.6us / 960ns (10 / 100Mbps) */

    TxLoopBack = (1 << 18) | (1 << 17), /* enable loopback test mode */
    TxCRC = (1 << 16),    /* DISABLE appending CRC to end of Tx packets */
    TxClearAbt = (1 << 0),    /* Clear abort (WO) */
    TxDMAShift = 8,        /* DMA burst value (0-7) is shifted this many bits */
    TxRetryShift = 4,    /* TXRR value (0-15) is shifted this many bits */

    TxVersionMask = 0x7C800000, /* mask out version bits 30-26, 23 */
};

/* Bits in RxConfig. */
enum rx_mode_bits {
    AcceptErr = 0x20,
    AcceptRunt = 0x10,
    AcceptBroadcast = 0x08,
    AcceptMulticast = 0x04,
    AcceptMyPhys = 0x02,
    AcceptAllPhys = 0x01,
};

enum ChipCmdBits {
    CmdReset = 0x10,
    CmdRxEnb = 0x08,
    CmdTxEnb = 0x04,
    RxBufEmpty = 0x01,
};

/* C+ mode */
enum CplusCmdBits {
    CPlusRxVLAN   = 0x0040, /* enable receive VLAN detagging */
    CPlusRxChkSum = 0x0020, /* enable receive checksum offloading */
    CPlusRxEnb    = 0x0002,
    CPlusTxEnb    = 0x0001,
};

// big endian
// ethernet frame
uint8_t packet[] = {
    /* 以太网帧 */
    // dst
    0x52, 0x54, 0x00, 0x12, 0x34, 0x57,
    // src
    0x52, 0x54, 0x00, 0x12, 0x34, 0x57,
    // 类型(代表IP协议)
    0x08, 0x00,
    
    /* IP数据报 */
    // 版本和首部长度
    (0x4 << 4) | 0x5,
    // TOS
    0x00,
    // 总长度
    0x00, 0x13,
    // 标识
    0xde, 0xad,
    // 标志(3bit)和片偏移(以8为基本单位，也就是相当于把标志的3bit当做0来计算)
    0x40, 0x00,
    // TTL
    0x40,
    // 上层协议，代表TCP
    0x06,
    // 首部校验和
    0xde, 0xad,
    // 源IP
    0x7f, 0x00, 0x00, 0x01,
    // 目的IP
    0x7f, 0x00, 0x00, 0x01,

    /* TCP数据报 */
    // 源端口
    0xde, 0xad,
    // 目的端口
    0xbe, 0xef,
    // Sequence Number
    0x00, 0x00, 0x00, 0x00,
    // Acknowledgement Number
    0x00, 0x00, 0x00, 0x00,
    // 报头长度等
    0x50,
    // 
    0x10,
    // Window size
    0xde, 0xed,
    // TCP checksum
    0xde, 0xad,
    // Urgent pointer
    0x00, 0x00
};

// RTL8139 Rx/Tx descriptor
typedef struct rtl8139_desc {
    uint32_t dw0;
    uint32_t dw1;
    uint32_t buf_lo;
    uint32_t buf_hi;
}rtl8139_desc;

// RTL8139 Rx/Tx ring
typedef struct rtl8139_ring {
    struct rtl8139_desc *desc;
    void *buffer;
}rtl8139_ring;

uint64_t gva_to_gpa(void *addr)
{
    int fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd < 0) {
        perror("open");
	exit(-1);
    }

    uint64_t pme, gfn;
    size_t offset;
    // offset = ((uint64_t)addr >> 9) & ~7;  // buggy
    offset = ((uintptr_t)addr >> 9) & ~7;
    lseek(fd, offset, SEEK_SET);
    read(fd, &pme, 8);
    if (!(pme & PAGE_PRESENT))
        return -1;
    gfn = pme & PAGE_PFN;

    return (gfn << PAGE_SHIFT) | ((uint64_t)addr & ((1 << PAGE_SHIFT) - 1));
}

void pmio_writeb(uint32_t data, uint32_t port)
{
    outb(data, PMIO_BASE+port);
}

void pmio_writew(uint32_t data, uint32_t port)
{
    outw(data, PMIO_BASE+port);
}

void pmio_writel(uint32_t data, uint32_t port)
{
    outl(data, PMIO_BASE+port);
}

uint32_t pmio_readb(uint32_t port)
{
    return (uint32_t)inb(PMIO_BASE+port);
}

uint32_t pmio_readw(uint32_t port)
{
    return (uint32_t)inw(PMIO_BASE+port);
}

uint32_t pmio_readl(uint32_t port)
{
    return (uint32_t)inl(PMIO_BASE+port);
}

void rtl8139_desc_config_rx(rtl8139_ring *ring, rtl8139_desc *desc, size_t nb)
{
    size_t buffer_size = RTL8139_BUFFER_SIZE + 4;
    for (int i = 0; i < nb; ++i) {
        memset(&desc[i], 0, sizeof(desc[i]));
        ring[i].desc = &desc[i];
        ring[i].buffer = aligned_alloc(PAGE_SIZE, buffer_size);
        
        memset(ring[i].buffer, 0, buffer_size);

        ring[i].desc->dw0 |= CP_RX_OWN;
        ring[i].desc->dw0 |= buffer_size;
        ring[i].desc->buf_lo = (uint32_t)gva_to_gpa(ring[i].buffer);
        // printf("buffer[%d]: 0x%x\n", i, ring[i].desc->buf_lo);  // for debug
    }
    pmio_writel((uint32_t)gva_to_gpa(desc), RxRingAddrLO);
    pmio_writel(0, RxRingAddrHI);
}

void rtl8139_desc_config_tx(rtl8139_desc *desc, void *buffer)
{
    memset(desc, 0, sizeof(rtl8139_desc));
    desc->dw0 |= CP_TX_OWN  |
                 CP_TX_EOR  |
                 CP_TX_LS   |
                 CP_TX_IPCS |
                 CP_TX_TCPCS|
                 CP_TX_LGSEN;
    desc->dw0 |= RTL8139_BUFFER_SIZE;
    desc->buf_lo = (uint32_t)gva_to_gpa(buffer);
    pmio_writel((uint32_t)gva_to_gpa(desc), TxAddr0);
    pmio_writel(0, TxAddr0+4);
}

void rtl8139_card_config()
{
    pmio_writel(TxLoopBack, TxConfig);
    pmio_writel(AcceptMyPhys, RxConfig);
    pmio_writew(CPlusRxEnb|CPlusTxEnb, CpCmd);
    pmio_writeb(CmdRxEnb|CmdTxEnb, ChipCmd);
}

void rtl8139_packet_send(void *buffer, void *packet, size_t len)
{
    if (len <= RTL8139_BUFFER_SIZE) {
        memcpy(buffer, packet, len);
        pmio_writeb(1<<6, TxPoll);
    }
}

void xxd(uint8_t *ptr, size_t size)
{
    for (int i = 0, j = 0; i < size; ++i, ++j) {
        if (i % 16 == 0) {
            j = 0;
            printf("\n0x%08x: ", (uint32_t)(ptr+i));
        }
        printf("%02x ", ptr[i]);
        if (j == 7) {
            printf("- ");
        }
    }
    printf("\n");
}

int main(int argc, char *argv[])
{
    // 44*1500 = 66000 > ip_data_len = 65535
    size_t rtl8139_rx_nb = 44;
    rtl8139_ring *rtl8139_rx_ring;
    rtl8139_desc *rtl8139_rx_desc, *rtl8139_tx_desc;

    rtl8139_rx_ring = (rtl8139_ring *)aligned_alloc(
        PAGE_SIZE, rtl8139_rx_nb*sizeof(rtl8139_ring)
    );

    rtl8139_rx_desc = (rtl8139_desc *)aligned_alloc(
        PAGE_SIZE, rtl8139_rx_nb*sizeof(rtl8139_desc)
    );

    rtl8139_tx_desc = (rtl8139_desc *)aligned_alloc(
        PAGE_SIZE, sizeof(rtl8139_desc)
    );

    void *rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE);
    iopl(3);

    rtl8139_desc_config_rx(rtl8139_rx_ring, rtl8139_rx_desc, rtl8139_rx_nb);
    rtl8139_desc_config_tx(rtl8139_tx_desc, rtl8139_tx_buffer);
    rtl8139_card_config();
    rtl8139_packet_send(rtl8139_tx_buffer, packet, sizeof(packet));

    sleep(7);

    for (int i = 0; i < rtl8139_rx_nb; ++i) {
    // for (int i = 0; i < 2; ++i) {
        xxd((uint8_t *)rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE);
    }
    return 0;
}
